
<html><head></head><body><h1 id="tasty">Tasty</h1>
<hr />
<p><a href="https://www.npmjs.com/package/tasty"><img src="https://img.shields.io/npm/v/tasty.svg" alt="npm" style="max-width: 100%;"></a>
<a href="https://travis-ci.org/chge/tasty"><img src="https://travis-ci.org/chge/tasty.svg?branch=master" alt="build" style="max-width: 100%;"></a>
<a href="https://ci.appveyor.com/project/chge/tasty"><img src="https://ci.appveyor.com/api/projects/status/github/chge/tasty?branch=master&amp;svg=true" alt="windows" style="max-width: 100%;"></a>
<a href="https://coveralls.io/github/chge/tasty?branch=master"><img src="https://coveralls.io/repos/github/chge/tasty/badge.svg?branch=master" alt="coverage" style="max-width: 100%;"></a>
<a href="https://codeclimate.com/github/chge/tasty"><img src="https://codeclimate.com/github/chge/tasty/badges/gpa.svg" alt="code climate" style="max-width: 100%;"></a></p>
<p>Tasty helps to test fully assembled web applications in near-production environments on real web clients by emulating real users.</p>
<pre><code class="lang-shell">npm install -g tasty
</code></pre>
<p>Tasty supports both multiple and single page applications (with server rendering too) and code coverage.
It respects <a href="https://www.w3.org/TR/CSP/">Content Security Policy</a> and SSL/TLS.</p>
<h1 id="how-it-works">How it works</h1>
<hr />
<p>Tasty server controls connected web clients to run your tests in runner of your choice against your application.</p>
<p><img src="https://github.com/chge/tasty/raw/master/test/demo/console.gif" alt="console" style="max-width: 100%;"></p>
<p>Client can emulate real user: navigate, fill forms, check page contents.</p>
<p><img src="https://github.com/chge/tasty/raw/master/test/demo/browser.gif" alt="browser" style="max-width: 100%;"></p>
<ol>
<li>Add <code>tasty.js</code> module to your assembly or markup.</li>
<li>Assemble and serve your application from staging server.</li>
<li>Provide CSP directives for Tasty and use test certificates, if needed.</li>
<li>Write tests for your preferred test framework using Tasty async tools.</li>
<li>Run Tasty server. Open application in any of your clients.</li>
<li>For each client Tasty will run your tests and return all output.</li>
<li>Edit tests, Tasty will re-run them automatically, if needed.</li>
</ol>
<h1 id="is-selenium-server-required-">Is <a href="https://github.com/SeleniumHQ/selenium">Selenium</a> server required?</h1>
<hr />
<p>No. Tasty client is intended to run inside browser environment without WebDriver.</p>
<p>But you'll probably need <a href="https://github.com/SeleniumHQ/selenium">Selenium</a>-driven clients or tools like <a href="http://phantomjs.org/">PhantomJS</a>, <a href="https://github.com/GoogleChrome/puppeteer">Puppeteer</a> and <a href="https://slimerjs.org/">SlimerJS</a> for automation.</p>
<h1 id="why-tasty-">Why Tasty?</h1>
<hr />
<p>The main purposes are:</p>
<ol>
<li>Emulate real user experience.</li>
<li>Support any web client without WebDriver.</li>
<li>Keep test scripts as simple as possible.</li>
</ol>
<p>Tasty gives you only high-level tools to help treat your application as a black box, just like real user does.
Interact with text and graphics, not with heartless HTML elements.
Try not to use knowledge of your application's markup, assume you're helping a real person to achieve some goals.</p>
<h1 id="similar-tools">Similar tools</h1>
<hr />
<p><a href="http://www.protractortest.org/">Protractor</a> and <a href="http://webdriver.io/">WebdriverIO</a> are <a href="https://github.com/SeleniumHQ/selenium">Selenium</a>-based end-to-end test frameworks useful for intergration testing. Also take a look at <a href="http://appium.io/">Appium</a>, <a href="http://casperjs.org/">CasperJS</a> and <a href="http://selendroid.io/">Selendroid</a>.</p>
<p><a href="https://karma-runner.github.io/1.0/index.html">Karma</a> and <a href="https://github.com/bitovi/testee">Testee</a> are great tools for cross-browser unit testing.</p>
<h1 id="example">Example</h1>
<hr />
<p>Serve your application.</p>
<pre><code class="lang-html">&lt;html&gt;
    &lt;head&gt;
        ...
        &lt;script src="//localhost:8765/tasty.js"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;form action="/dashboard"&gt;
            Welcome!
            &lt;input placeholder="Username" type="text" /&gt;
            &lt;input placeholder="Password" type="password" /&gt;
            &lt;input value="Log in" type="submit" /&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Write a test (this one uses <a href="https://mochajs.org/">Mocha</a>).</p>
<pre><code class="lang-javascript">describe('login form', function() {
    it('logs user in', function() {
        is(text('Welcome!'));
        click(text('Username'));
        type(tasty.config.username);
        click(text('Password'));
        type(tasty.config.password);
        click(text('Log in'));
        is(location('/dashboard'));

        return now();
    });
});
</code></pre>
<p>Run Tasty server.</p>
<pre><code class="lang-shell">tasty test.js --username 'John Doe' --password 'secret!'
</code></pre>
<p>Open your application in your client. Tasty will run the test, print all output and exit.</p>
<h1 id="configuration">Configuration</h1>
<hr />
<p>Either use Tasty from command line or from your code using <a href="https://chge.github.io/tasty/?api=server">API</a>.</p>
<p>Tasty can read any <a href="https://chge.github.io/tasty/?api=server#Tasty">configuration</a> fields from JSON file provided by <code>--config &lt;path/to/config&gt;</code> flag.</p>
<p>See <code>tasty --help</code> for more information.</p>
<h1 id="server">Server</h1>
<hr />
<p>Tasty server is a bridge between the clients and the test runner, it controls each client and runs tests written using Tasty tools.</p>
<p>Use <code>--url</code> flag to configre server's own URL.</p>
<h1 id="runner">Runner</h1>
<hr />
<p>Tasty supports any test frameworks that support asynchronous tests.</p>
<p>Check out the <a href="https://chge.github.io/tasty/?api=test">API available for tests</a>.</p>
<p>There are built-in runners for <a href="https://mochajs.org/">Mocha</a>, <a href="https://jasmine.github.io/">Jasmine</a> and <a href="https://qunitjs.com/">QUnit</a>. Provide <code>--runner &lt;name&gt;</code> flag to use one of them. For other frameworks, use Tasty programmatically from your runner.</p>
<p><a href="http://chaijs.com/">Chai</a>, its <a href="http://chaijs.com/plugins">plugins</a> and other helper libraries are supported by providing <code>--addon &lt;name&gt;,&lt;name&gt;...</code> flag.
For example, <code>--addon chai,chai-as-promised,chai-http</code> works fine.</p>
<p>Use <code>--watch</code> flag to watch for changes or run on several clients.</p>
<p>Tasty spawns <a href="https://www.npmjs.com/package/tasty-sandbox">sandboxed</a> runner and coverage tool for each client separately,
so it's easy to test in parallel.</p>
<h1 id="client">Client</h1>
<hr />
<p>Tasty client is a small extendable UMD module that connects to the server and executes its commands.</p>
<p>It has its own <a href="https://chge.github.io/tasty/?api=client">API</a> and isolated polyfills for non-supporting browsers.</p>
<p>Load <code>tasty.min.js</code> or use <code>--embed min</code> if you don't need to debug your tests.</p>
<h1 id="static-server">Static server</h1>
<hr />
<p>You can run built-in static server on the same URL by passing <code>--static &lt;path/to/root&gt;</code> flag.
Use <code>--static-index &lt;path/to/index&gt;</code> flag for SPAs and add <code>--embed</code> flag to inject Tasty client automatically.</p>
<h1 id="code-coverage">Code coverage</h1>
<hr />
<p>When serving application from its own server, you should instrument JavaScript code for coverage by yourself.
Tasty's static server has built-in support for <a href="https://gotwarlost.github.io/istanbul">Istanbul</a> and <a href="https://istanbul.js.org/">NYC</a> (aka Istanbul 2) to automatically do it for you.</p>
<h1 id="csp">CSP</h1>
<hr />
<p>For Tasty server running on <code>localhost:8765/path</code> you should add the following CSP directives for Tasty client to work properly:</p>
<pre><code>connect-src ws://localhost:8765/path
script-src localhost:8765/path
</code></pre><p>Change <code>ws</code> to <code>wss</code> if you serve from HTTPS.</p>
<p>Unfortunately, both <a href="https://gotwarlost.github.io/istanbul">Istanbul</a> and <a href="https://istanbul.js.org/">NYC</a> instrumenters use <code>new Function()</code> to get top-level scope.
To use one of them, you have to add the following directive:</p>
<pre><code>script-src 'unsafe-eval'
</code></pre><p>If you use <code>&lt;meta /&gt;</code> for CSP, Tasty's static server automatically injects that directive into HTML files when <code>--coverage &lt;name&gt;</code> flag is used.</p>
<p>Remember, CSP allows consequently applied directives to only restrict the resulting set, i.e. meta tags can't expand/loose header directives and vice versa.</p>
<p>Check out a <a href="https://report-uri.io/home/generate">great tool</a> for generating and validating CSP directives.</p>
<h1 id="api-reference">API reference</h1>
<hr />
<ul>
<li><a href="https://chge.github.io/tasty/">Introduction</a></li>
<li><a href="https://chge.github.io/tasty/?api=client">Client API</a></li>
<li><a href="https://chge.github.io/tasty/?api=server">Server API</a></li>
<li><a href="https://chge.github.io/tasty/?api=test">Test API</a></li>
</ul>
<h1 id="browser-support">Browser support</h1>
<hr />
<p><a href="https://saucelabs.com/u/tasty"><img src="https://saucelabs.com/buildstatus/tasty" alt="sauce labs" style="max-width: 100%;"></a></p>
<p><a href="https://saucelabs.com/u/tasty"><img src="https://saucelabs.com/browser-matrix/tasty.svg" alt="browser support" style="max-width: 100%;"></a></p>
<h1 id="known-issues">Known issues</h1>
<hr />
<h3 id="sandbox">Sandbox</h3>
<p>Tasty client runs inside JavaScript sandbox, so it simply can't emulate <em>real</em> interaction,
as <a href="https://developer.chrome.com/devtools/docs/debugger-protocol">debugging</a> <a href="https://wiki.mozilla.org/Remote_Debugging_Protocol">protocols</a> or <a href="https://www.w3.org/TR/webdriver/">WebDriver</a> can.</p>
<h3 id="highly-fragmented-text">Highly fragmented text</h3>
<p>Currently Tasty can't find text <code>+1 123 456-78-90</code> in the following case:</p>
<pre><code class="lang-html">+1 &lt;input type="tel" placeholder="123 456-78-90" /&gt;
</code></pre>
<p>In other words, it's too hard to join text fragments of <code>textContent</code>, <code>value/placeholder</code>, <code>:before/:after</code> etc.</p>
<p>Also, search cannot detect text from <code>alt</code> attribute yet.</p>
<h3 id="media">Media</h3>
<p>Border images are currently skipped.</p>
<p>Also, <code>&lt;audio /&gt;</code>, <code>&lt;video /&gt;</code>, <code>&lt;picture /&gt;</code>, <code>&lt;object /&gt;</code> and <code>&lt;embed /&gt;</code> are not supported out-of-the-box.</p>
<h3 id="auto-focus-elements">Auto-focus elements</h3>
<p>When using auto-focus elements (such as <code>&lt;input /&gt;</code>), you could encounter <code>cannot type into active node &lt;body /&gt;</code> error when window loses its focus, which causes <code>type</code> and <code>paste</code> tools to fail.</p>
<p>If you don't want to focus such elements explicitly (using <code>click</code> or something else), make sure that client window remain focused during tests.
For WebDriver clients you could <a href="https://www.w3.org/TR/webdriver/#maximize-window">maximize window</a> or use <a href="http://stackoverflow.com/a/19170779"><code>alert()</code> workaround</a> to focus reliably.</p>
<p>Additionally, <a href="https://developer.chrome.com/devtools">Chrome DevTools</a> could force current tab to lose focus, with the same results.</p>
<p>Remember, you can always click on something to reset autofocus when you don't need to test it.</p>
<h3 id="shadow-dom">Shadow DOM</h3>
<p>Not supported yet.</p>
<h3 id="browser-ui">Browser UI</h3>
<p>Some elements of browser itself, such as tooltips from <code>title</code> attribute or HTML5 Form validation messages, could be potentially detected, but currently aren't supported.</p>
<h3 id="arrow-functions">Arrow functions</h3>
<pre><code class="lang-javascript">exec(() =&gt; {
    ...
});
</code></pre>
<p>The lambda above will be called on the client "as is", so if it doesn't support arrow functions, the call will fail. It's more safe to always use <code>function</code> literals in such cases.</p>
<h3 id="console">Console</h3>
<p>Tasty console output could be wrong or confusing if <code>window.console</code> is modified by your application. If this is the case, make sure Tasty client code is runnig prior to application code.</p>
<h3 id="http---https-on-the-same-port">HTTP + HTTPS on the same port</h3>
<p>Not supported yet.</p>
<h1 id="tools">Tools</h1>
<hr />
<h3 id="queue">Queue</h3>
<p>Each tool adds corresponding action to the runner queue instead of performing that action immediately.
This allows to write tests in synchronous manner.</p>
<pre><code class="lang-javascript">click('Name');
type('John Doe');
click('Save');
</code></pre>
<p>Queue is executed after <code>now()</code> call without arguments, which returns <code>Promise</code> instance.</p>
<pre><code class="lang-javascript">it('does something', function() {
    ...
    return now();
});
</code></pre>
<p>Your testing framework may prefer callback for async tests.</p>
<pre><code class="lang-javascript">it('works', function(done) {
    ...
    now().then(done, done);
});
</code></pre>
<h3 id="ready-state">Ready state</h3>
<p>For testing SPA (or rich MPA) you can provide a method for Tasty to ensure that client is ready for the next action.</p>
<p>The simpliest way is to just wait before or after using some tools.</p>
<pre><code class="lang-javascript">ready('delay', 1000);
</code></pre>
<p>You may override the list of tools to wait before and after.</p>
<pre><code class="lang-javascript">ready('delay', 1000, ['exec'], ['click']);
</code></pre>
<p>You always can manually add a delay into queue.</p>
<pre><code class="lang-javascript">delay(1000);
</code></pre>
<p>There could be enough to just check if DOM is ready...</p>
<pre><code class="lang-javascript">ready('document'); // 'DOMContentLoaded' aka 'interactive' readyState
</code></pre>
<pre><code class="lang-javascript">ready('window'); // 'load' aka 'complete' readyState
</code></pre>
<p>...and maybe wait a little bit.</p>
<pre><code class="lang-javascript">ready('document', 300);
</code></pre>
<pre><code class="lang-javascript">ready('window', 300);
</code></pre>
<p>Another way is to provide some application-specific code.</p>
<pre><code class="lang-javascript">ready(
    'until',
    // This function is executed on client, test will continue when it will return true.
    function() {
        return !document.getElementsByClassName('progress').length;
    },
    ...
);
</code></pre>
<pre><code class="lang-javascript">ready(
    'exec',
    // This function is executed on client, test will continue when promise will be resolved.
    function(tasty) {
        // utils.Promise is a built-in implementation for non-supporting browsers.
        return new this.utils.Promise(
            function(resolve, reject) {
                ...
            }
        );
    },
    ...
);
</code></pre>
<p>Call without arguments simply executes <code>ready</code> logic, which is useful in some cases.</p>
<pre><code class="lang-javascript">ready('exec', ...);
click('Start');
is('Loading...');
ready();
is('Done');
</code></pre>
<p>Note that ready methods cannot be combined.</p>
<h3 id="custom-logic">Custom logic</h3>
<p>The <code>now(...)</code> call with function(s) allows you to add some custom logic into test, but you should use <code>now.*</code> namespace for tools.</p>
<p>The <code>now.smth()</code> is the same as just <code>smth()</code>, but runs immediately. You should use <code>now.*</code> tools inside <code>now(...)</code> call if you don't want to break execution order.</p>
<pre><code class="lang-javascript">it('chooses', function() {
    now(
        () =&gt; now.is(text('Welcome back'))
            .then(
                () =&gt; now.click('Log in'),
                () =&gt; now.click('Sign up')
            )
    );

    return now();
});
</code></pre>
<p>Some tools, like <code>during()</code> and <code>until()</code>, accepts functions that will be already queued, so feel free to use <code>now.smth()</code> from them.</p>
<pre><code class="lang-javascript">it('searches', function() {
    until(
        () =&gt; now.is(text('Chapter 42', 'h1'))
            .catch((error) =&gt; {
                now.click('Next');
                throw error;
            })
    );
    click('Bookmark');

    return now();
});
</code></pre>
<h1 id="security-recommendations">Security recommendations</h1>
<hr />
<p>On staging or other near-production environment, Tasty can't pass (re)CAPTCHA or two-factor authentication for you.</p>
<h3 id="permanent-secrets">Permanent secrets</h3>
<p>Store passwords in your Continuous Integration tool and pass credentials into command line. All arguments will be available in <code>tasty.config</code> object.</p>
<p>If you're automatically taking screenshots or recording videos during test run, they could potentially contain passwords (e.g. typed into wrong fields because of error) or other sensitive data.</p>
<p>Also, Tasty logs all typed/pasted text into browser console.</p>
<h3 id="one-off-secrets">One-off secrets</h3>
<p>Get two-factor nonces from backdoor or use paid services to mock real mobile phones.</p>
<h3 id="-re-captcha">(re)CAPTCHA</h3>
<p>Use <a href="https://developers.google.com/recaptcha/docs/faq">reCAPTCHA testing <code>sitekey</code> and <code>secret</code></a> for testing environment.</p>
<p>Instead of trying to click on iframed content, simply fake reCAPTCHA response with some suitable string, e.g.</p>
<pre><code class="lang-javascript">exec(function() {
    document.querySelector('[name="g-recaptcha-response"]').value = '03AHJ_VuvHyNQjrLnMZ6eGbmdDZQ3Qma4CBrMSWSOzTcqB8rdl3tbIN1gzAWkB4jPi1qCE-aEw-hx7ns9DuzwNe7bW4E5rCc23SDFs9fQJGqAM27AeNKeg0q6ByJEC3ig3ydkrEzwVd56fi1oyDTVAvwpGCTtg8rjBRYqwn7qDnCp8Fw6Iq6h5vQKc7KtX4mW33QUL8Y5HzJReMDqZio8Rf6zmyqGGcOurvo6Gw4_exJfwcnK0CcnQUpbjlr3-9Mm-1fKeUq_q6s6plM7-2Rc2WNgYdguvp6yxZyyxr5IUKZk1eCvwgxu97zdbM3bPjfuuccrvie4LTGjasRYobPF51H5TbSm3-FacdHJ5usgMSjII6Cba7IaH4NQDPJqyO7ltWH1uPPRybuJmJk1AWALebHTiM-4loixaiI-47JCrBUeJGPPR9A8Q1UfduaZmzP0CrDj5YfFbVzHncDh4ac_KghXgehxbEQ2eD2Qwo18wlc87U-aQQqJLBkvlRUABHDGeWcyRvEzTPnpXfsmbK7Y2WlU4_zbCqtVAdR-pmp3MALqA-njyDtRZmtHsvsVVGvtVXy9UMlGRc4YwmvSyxg0fRegX13K7lMfnY9qqoNV23ZtB3fiQTUwjZnAe0F3KKArRTAt4XFjOJKIaz6-8TxHtqcPfejehTpkOJ0M7cDB3wi9_7BxNu758D6CfqgAXGKqH-kV42K6SJ69S50Lhl3t1l7rEWXmJi5vCEvQ2yHReL1XGtNygpt-WM0qlDiGswUITnUSire2c0JU84vTQCQ3AFZLWXX3eypwRHmyWXvUQAho9LqHZuV_qXoyiyK0SbCZW6lSW4CucElsy5XOpNAFCTgxtY4gTZgnR9uB_JHCjF69ibMeQeUPGNWahECJiRp49TpZi928wvGY_';
});
</code></pre>
<p>For testing <code>sitekey</code> and <code>secret</code>, reCAPTCHA server should accept the same <code>g-recaptcha-response</code> unlimited number of times.</p>
<p>If example above doesn't work (e.g. response format is changed), get new fake <code>g-recaptcha-response</code> string:</p>
<ul>
<li>manually click on testing reCAPTCHA,</li>
<li>inspect XHR response or <code>value</code> property of <code>&lt;textarea name="g-recaptcha-response" /&gt;</code> on the page.</li>
</ul>
<p>For other CAPTCHA implementations, get answers from backdoor.</p>
<h3 id="ssl-tls">SSL/TLS</h3>
<p>Do not use production certificates with Tasty: server is not intended to be accessible from external networks.</p>
<p>Use <a href="https://letsencrypt.org/">Let's encrypt</a>, self-signed non-CA certificates or set up your own CA.</p>
<h1 id="building">Building</h1>
<hr />
<pre><code class="lang-shell">npm run prepublish
</code></pre>
<h1 id="testing">Testing</h1>
<hr />
<pre><code class="lang-shell">npm test
</code></pre>
<p>Main tests use <a href="https://slimerjs.org/">SlimerJS</a> and <a href="http://phantomjs.org/">PhantomJS</a>. SlimerJS itself requires <a href="https://www.mozilla.org/firefox">Firefox</a> to be installed. PhantomJS suite requires <code>phantomjs</code> to be available via command prompt.</p>
<p>Because of tests for obsolete AppCache manifest, PhantomJS could put HTML page into persistent cache and then ignore <code>clearMemoryCache</code> API calls. This may require to delete cache files manually from the following locations:</p>
<ul>
<li><code>%HOMEDRIVE%%HOMEPATH%\AppData\Local\Ofi Labs\PhantomJS</code></li>
<li><code>~/Library/Caches/Ofi Labs/PhantomJS</code></li>
<li><code>~/.local/share/Ofi Labs/PhantomJS/</code></li>
</ul>
<h3 id="browser-support">Browser support</h3>
<pre><code class="lang-shell">npm run support
</code></pre>
<p>Real-browser support tests are made possible by <a href="https://saucelabs.com/">SauceLabs</a>. Automation requires <code>SAUCE_USERNAME</code> and <code>SAUCE_ACCESS_KEY</code> environment variables,
which are kindly provided by <a href="https://docs.travis-ci.com/user/sauce-connect">TravisCI</a>.</p>
<h1 id="windows">Windows</h1>
<hr />
<p><a href="https://ci.appveyor.com/project/chge/tasty"><img src="https://ci.appveyor.com/api/projects/status/github/chge/tasty?branch=master&amp;svg=true" alt="windows" style="max-width: 100%;"></a></p>
<p>Everything works fine, yay!</p>
</body></html>